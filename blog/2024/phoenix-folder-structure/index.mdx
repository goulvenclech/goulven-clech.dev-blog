---
title: "Directory structure with Phoenix"
date: 2024-01-30
tags: 
  - "web development"
  - "elixir"
  - "phoenix"
  - "devops"
image: "./phoenix_cover.jpg"
image_alt: "Astro logo on a colorful background"
image_caption: "A young british developer, trying to find a file in his project."
icon: "üóÇÔ∏è"
abstract: "How do you organize an Elixir/Phoenix directory structure to scale? A real case study on a real-estate start-up."
display_abstract: true
display_cover: true
display_toc: true
published: "1.3.0"
---

import HiddenH3 from "$components/hidden/HiddenH3.astro"
import Asterism from "$components/typography/Asterism.astro"
export const components = {h3: HiddenH3}


## What's the problem?

The Phoenix documentation offers a [directory structure example](https://hexdocs.pm/phoenix/directory_structure.html) for new projects, mainly detailed for the front-end part.

But our tiny [real-estate start-up]() has grown over three years, with different developers and new features. Sadly, our back-end directory structure hasn't evolved with it and has become a mess.

To be honest, I am extensively to blame for this situation. After the departure of the company's first developer, I remained alone as a junior developer. Intending to recruit another CTO, I kept the initial philosophy of the project as long as possible, and delayed essential architectural decisions.

Even when the recruitment difficulty became apparent, I took a while before stepping up as the tech lead. I suffered through the situation, which seemed beyond my control. And when we compensated with freelancers/ interns, I didn't dare nor know how to manage them correctly, leading to less coherent or qualitative code.

Today, the situation is different, as I gradually regained control of the project and built my confidence. I have built a team of five people, including three software developers, destined to grow. And now, it is time to re-organize our project.

### Inconsistent structures

<Asterism />

Let's consider an extract of the old structure : 

```
encheres_immo/
‚îú‚îÄ accounts.ex <- multi-schemas context
‚îú‚îÄ accounts/
‚îÇ    ‚îú‚îÄ user.ex <- schema
‚îÇ    ‚îú‚îÄ organization.ex <- schema
‚îÇ    ‚îú‚îÄ formula.ex <- child schema
‚îÇ    ‚îî‚îÄ [... utils]
‚îú‚îÄ auctions.ex <- context
‚îú‚îÄ auctions/
‚îÇ    ‚îú‚îÄ projections/
‚îÇ    ‚îÇ    ‚îú‚îÄ auction.ex <- schema
‚îÇ    ‚îÇ    ‚îî‚îÄ [... utils]
‚îÇ    ‚îú‚îÄ currency.ex <- child schema
‚îÇ    ‚îî‚îÄ [... utils]
‚îú‚îÄ contacts/
‚îÇ    ‚îú‚îÄ contacts.ex <- context
‚îÇ    ‚îú‚îÄ contact.ex <- schema
‚îÇ    ‚îî‚îÄ [... utils]
[...]
‚îú‚îÄ application.ex <- app life cycle
‚îú‚îÄ release.ex <- utils for migrations and seeding
‚îî‚îÄ [... repo related files]
```

If we can identify three contexts in this example (`accounts`, `auctions`, and `contacts`), their inconsistent structure makes the whole project hard to understand.

Additionally, some of these structures simply don't work. For example, instead of `users` and `organizations` context with their related functions, we have an abnormally long and messy `accounts.ex`. Worse, schemas file `user.ex` and `organization.ex` contain some functions that should also be in context.

This situation arose from poorly documented personal logic, followed by various developers interpreting it in their own way. We can guess the origin of some problems: 
1. The first developer wanted to conveniently group accounts' functions, but their number made this file unreadable.  
2. Another developer (maybe me) wanted to reduce this file by putting the simplest functions with their schema, making unclear if a function should be in the context or with the the schema.
3. With an absurdly big "accounts" folder next to a small "contacts" folder, it's now unclear when a feature should have its folder. This decision became at the discretion of each developer.
4. Let that sink for a few years and Ta-da!  


## Main considerations

Before starting to iterate, I knew my solution must address several considerations.

First, our system should be versatile enough to cover all existing and future features, while remaining consistent. It should also allow scaling small subfeatures into larger ones.

Second, "What is conceived well is expressed clearly". If good readability and consistency are the main objectives, this should make our solution easy to document and, therefore, easy to enforce. A few paragraphs explaining key concepts and a structure diagram should be enough.

Finally, I want to involve the current team as much as possible in decision-making. This approach will not only lead to a better solution but also ensure that the entire team is familiar with the solution, making it easier to implement initially.

## Three errors to avoid

We made several iterations before finding the right one. Some were deliberately radical and helped us to identify wrong directions.

### Nesting hell

Here is our initial proposal based on [this article](https://dev.to/pedromtavares/blazing-with-phoenix-project-structure-463l), with some personal modifications. Each feature is in a folder, inside its parent feature, and so on, following the schema relations.

```
encheres_immo/
‚îú‚îÄ accounts/
‚îÇ    ‚îú‚îÄ accounts.ex <- multi-schemas context
‚îÇ    ‚îú‚îÄ organizations/
‚îÇ    ‚îÇ    ‚îú‚îÄ organizations.ex <- context
‚îÇ    ‚îÇ    ‚îú‚îÄ organization.ex <- schema
‚îÇ    ‚îÇ    ‚îú‚îÄ formulas/
‚îÇ    ‚îÇ    ‚îÇ    ‚îú‚îÄ formulas.ex <- child context
‚îÇ    ‚îÇ    ‚îÇ    ‚îî‚îÄ formula.ex <- child schema
‚îÇ    ‚îÇ    ‚îî‚îÄ [... other child folders]
‚îÇ    ‚îî‚îÄ users/
‚îÇ         ‚îú‚îÄ users.ex <- context
‚îÇ         ‚îú‚îÄ user.ex <- schema
‚îÇ         ‚îî‚îÄ [... other child folders]
[...]
‚îú‚îÄ application.ex <- app life cycle
‚îú‚îÄ release.ex <- utils for migrations and seeding
‚îî‚îÄ [... repo related files]
```

This solution has several advantages:  fewer files at the root, coherent structures throughout, and allowing multi-schema contexts (if necessary). Also, module names follow schema relations:

```
EncheresImmo.Accounts.Organizations.Formulas.Formula
Lib -> Parent -> Parent -> Context -> Schema
```

One of the downsides of this solution is that it may result in more and more folders nested inside folders, making it challenging to access deeply nested files. With time, module names will be longer and harder to guess, such as : `EncheresImmo.Accounts.Organizations.PaymentInfos.Cards.Card`.

Finally, complex relations like `Users`-`Orgs` or many-to-many tables can be tricky to represent as a nested hierarchy.

### Scrolling hell

<Asterism />

For thought, we can try the opposite approach:

```
encheres_immo/
‚îú‚îÄ organizations/
‚îÇ    ‚îú‚îÄ organizations.ex <- context
‚îÇ    ‚îú‚îÄ organization.ex <- schema
‚îÇ    ‚îî‚îÄ [... utils]
‚îú‚îÄ formulas/
‚îÇ    ‚îú‚îÄ formulas.ex <- context
‚îÇ    ‚îî‚îÄ formula.ex <- schema
‚îú‚îÄ users/
‚îÇ    ‚îú‚îÄ users.ex <- context
‚îÇ    ‚îú‚îÄ user.ex <- schema
‚îÇ    ‚îî‚îÄ [... utils]
[...]
‚îú‚îÄ application.ex <- app life cycle
‚îú‚îÄ release.ex <- utils for migrations and seeding
‚îî‚îÄ [... repo related files]
```

Like the previous solution, we clean files at the root and get a coherent structure throughout. But this time, every schema has its folder with context/schema/utils, making module names easy to guess.

```
EncheresImmo.Users.User
Lib -> Context -> Schema
```

However, there are drawbacks to this solution, including a potentially large number of folders at the root level, with no clear distinction between the central feature and the small sub-feature. Also, folder structure and module names do not represent schema relations. 

### Messy hell

<Asterism />

My colleague tried two solutions, which can be summarized as follows:

```
encheres_immo/
‚îú‚îÄ accounts/
‚îÇ    ‚îú‚îÄ accounts.ex <- multi-schemas context
‚îÇ    ‚îú‚îÄ custom_themes.ex <- context
‚îÇ    ‚îú‚îÄ schema/
‚îÇ    ‚îÇ    ‚îú‚îÄ organization.ex <- schema
‚îÇ    ‚îÇ    ‚îú‚îÄ user.ex <- schema
‚îÇ    ‚îÇ    ‚îú‚îÄ custom_theme.ex <- schema
‚îÇ    ‚îÇ    ‚îî‚îÄ [... other schemas]
‚îÇ    ‚îî‚îÄ [... utils]
‚îú‚îÄ contacts/
‚îÇ    ‚îú‚îÄ contacts.ex <- context
‚îÇ    ‚îú‚îÄ schema/
‚îÇ    ‚îÇ    ‚îî‚îÄ contact.ex <- schema
‚îÇ    ‚îî‚îÄ [... utils]
[...]
‚îú‚îÄ application.ex <- app life cycle
‚îú‚îÄ release.ex <- utils for migrations and seeding
‚îî‚îÄ [... repo related files]
```

This architecture features less nesting compared to the first proposal and fewer folders than the second one. Additionally, It makes a clearer distinction between context files and schema files, and allows multi-schemas context.

However, I don't think there is a necessity for multi-schemas contexts, such as `Accounts`. Upon reviewing our code, such functions would either belong in a distinct context or are poor programming practices.

Moreover, this solution does not distinguish schemas/contexts associated with more extensive features. When we multiply subsidiary schemas/contexts, this quickly leads to a messy folder:

```
encheres_immo/
‚îú‚îÄ accounts/
‚îÇ    ‚îú‚îÄ accounts.ex <- multi-schemas context
‚îÇ    ‚îú‚îÄ custom_themes.ex <- context
‚îÇ    ‚îú‚îÄ formulas.ex <- context
‚îÇ    ‚îú‚îÄ payment_infos.ex <- context
‚îÇ    ‚îú‚îÄ [... other contexts]
‚îÇ    ‚îú‚îÄ schema/
‚îÇ    ‚îÇ    ‚îú‚îÄ organization.ex <- schema
‚îÇ    ‚îÇ    ‚îú‚îÄ custom_theme.ex <- schema
‚îÇ    ‚îÇ    ‚îú‚îÄ formula.ex <- schema
‚îÇ    ‚îÇ    ‚îú‚îÄ payment_info.ex <- schema
‚îÇ    ‚îÇ    ‚îî‚îÄ [... other schemas]
‚îÇ    ‚îî‚îÄ [... utils]
[...]
```

## Our final proposal

Not the miracle solution, but I think I found one halfway of all our solutions:

```
encheres_immo/
‚îú‚îÄ organizations/ <- a folder for each feature
‚îÇ    ‚îú‚îÄ organizations.ex <- context 
‚îÇ    ‚îú‚îÄ organization.ex <- schema & changesets
‚îÇ    ‚îú‚îÄ ? - utils/ <- utils folder
‚îÇ    ‚îÇ       ‚îî‚îÄ [... utils].ex <- utils files 
‚îÇ    ‚îî‚îÄ ? -  formula/ <- subfolder for each child feature
‚îÇ            ‚îú‚îÄ formula.ex <- child schema & changesets
‚îÇ            ‚îú‚îÄ ? - formulas.ex <- child context 
‚îÇ            ‚îî‚îÄ ? - [... utils] <- child utils 
[...]
‚îú‚îÄ application.ex <- app life cycle
‚îú‚îÄ release.ex <- utils for migrations and seeding
‚îî‚îÄ [... repo related files]
```

A "Feature" is a data structure (example: `user`), with a schema (and changesets), a context (functions to create/ use/ modify/ delete it), utils (optional - additional functions, boilerplates, templates, or behaviours), and child features (optional - embed or small tables).

A "Child feature" is a simple schema/ embed (example: `formula`) with few to none context functions, and few to none utils. A child feature can't have a child feature itself. If a child feature grows into a feature, we should transfer it to its own folder. 

The primary benefit of this solution is its ease of documentation, requiring just one schema and two paragraphs to explain. Furthermore, despite its straightforward approach, it stays versatile enough to ensure compatibility with our existing codebase.

Additionally, even if the module name doesn't fully describe the entire hierarchy as the first proposal does, it still enables us to grasp the module's immediate relationships. And it remains concise and straightforward to deduce, like the second proposal :

```
EncheresImmo.Organizations.Formulas.Formula
Lib -> Feature -> Subfeature -> Schema
```

Drawbacks include the eventual proliferation of folders at the root, but this should stay slower than the second proposal and without the nesting (seen in the first proposal) or messy (noted in the third proposal) issues. Finally, if this method requires adjustments to the folder structure each time a sub-feature is upgraded to a main feature, but those instances should be rare.

### About test files

<Asterism />

To respect legacy code and documention, we will keep a `test` folder at the root of the project, with a `test_helper.exs`.

-> Not the solution I would have chosen, but I think it's the best compromise between respecting the existing code and making it evolve.
-> In my personal project, I will try to move a test file in the folder of each feature, and see if it's possible to make it work.

## About the decision process

As I said in the introduction, this is one of my first big decisions as a tech lead. I wanted to involve the team in the process, not only to make a better decision or for democratic management, but also to reassure myself.

### How did we discuss it?

It was also the first opportunity to formalize my decision process, and I knew that writing would play a central part. Of course, some discussions happened in meetings, but I tried to keep a written trace of it, so I created a Github Issue. 

There are multiple benefits in using GitHub Issues. Firstly, these issues are stored in the repository, making them easily accessible. Additionally, writing allows us to express our thoughts clearly, illustrate them with examples, and review proposals from others. By doing so, we can see the progression of the discussion and how we reached the final decision.

We took a few days to discuss the proposal and make the necessary changes, but the effort paid off. By involving everyone, we made a more informed decision that everyone knows about. More oral meetings or rushing the decision alone would not have saved time in the long run.

### How did we document it?

<Asterism />

At the end of the discussion, we have to write down the final decision, and to document it.
-> Added in the `README.md` with a schema, and a few paragraphs.

In retrospect, I think it whould have been better to :
-> Open a PR with the final decision, and to discuss it in the comments and code review.
-> Allow others devs to comment on the PR, and to propose their changes to the documentation.
-> Have a file in `docs/` with the final decision, with more details.

## What I learned

Blabla.
