---
title: "Directory structure with Phoenix"
date: 2024-01-30
tags: 
  - "web development"
  - "elixir"
  - "phoenix"
  - "devops"
image: "./phoenix_cover.jpg"
image_alt: "Astro logo on a colorful background"
image_caption: "A young british developer, trying to find a file in his project."
icon: "üóÇÔ∏è"
abstract: "How do you organize an Elixir/Phoenix directory structure to scale? A real case study on a real-estate start-up."
display_abstract: true
display_cover: true
display_toc: true
published: "1.3.0"
---

import HiddenH3 from "$components/hidden/HiddenH3.astro"
import Asterism from "$components/typography/Asterism.astro"
export const components = {h3: HiddenH3}


## What's the problem?

The Phoenix documentation offers a [directory structure example](https://hexdocs.pm/phoenix/directory_structure.html) for new projects, mainly detailed for the front-end part.

But our tiny [real-estate start-up]() has grown over three years, with different developers and new features. Sadly, our back-end directory structure hasn't evolved with it and has become a mess.

To be honest, I am extensively to blame for this situation. After the departure of the company's first developer, I remained alone as a junior developer. Intending to recruit another CTO, I kept the initial philosophy of the project as long as possible, and delayed essential architectural decisions.

Even when the recruitment difficulty became apparent, I took a while before stepping up as the tech lead. I suffered through the situation, which seemed beyond my control. When we compensated with freelancers/ interns, I didn't dare nor know how to manage them correctly, leading to less coherent or qualitative code.

Today, the situation is different, as I gradually regained control of the project and built my confidence. I have built a team of five people, including three software developers, destined to grow. And now, it is time to re-organize our project.

### Inconsistent structures

<Asterism />

Let's consider an extract of the old structure : 

```
encheres_immo/
    [...config files]
    
    - accounts.ex <- multi-schemas context
    - accounts/
        - user.ex <- schema
        - organization.ex <- schema
        - formula.ex <- child schema
        - [...utils]
        
    - auctions.ex <- context
    - auctions/
        - projections/
            - auction.ex <- schema
        - currency.ex <- child schema
        - [...utils]

    - contacts/
        - contacts.ex <- context
        - contact.ex <- schema
        - [...utils]
```

If we can identify three contexts in this example (`accounts`, `auctions`, and `contacts`), their inconsistent structure makes the whole project hard to understand.

Additionally, some of these structures simply don't work. For example, instead of `users` and `organizations` context with their related functions, we have an abnormally long and messy `accounts.ex`. Worse, schemas file `user.ex` and `organization.ex` contain some functions that should also be in context.

This situation arose from poorly documented personal logic, followed by various developers interpreting it in their way. We can guess the origin of some problems: 
1. The first developer wanted to conveniently group accounts' functions, but their number made this file unreadable.  
2. Another developer (maybe me) wanted to reduce this file by putting the simplest functions with their schema, making unclear if a function should be in the context or with the the schema.
3. With an absurdly big "accounts" folder next to a small "contacts" folder, it's now unclear when a feature should have its folder. This decision became at the discretion of each developer.
4. Let that sink for a few years and Ta-da!  


## Main considerations

Before starting to iterate, I knew my solution must address several considerations.

First, our system should be versatile enough to cover all existing and future features, while remaining consistent. It should also allow scaling small subfeatures into larger ones.

Second, "What is conceived well is expressed clearly". If good readability and consistency are the main objectives, this should make our solution easy to document and, therefore, easy to enforce. A few paragraphs explaining key concepts and a structure diagram should be enough.

Finally, I want to involve the current team as much as possible in decision-making. This approach will not only lead to a better solution but also ensure that the entire team is familiar with the solution, making it easier to implement initially.

## Three errors to avoid

We made several iterations before finding the right one. Some were deliberately radical and helped us to identify wrong directions.

### Nesting hell

Here is our initial proposal based on [this article](https://dev.to/pedromtavares/blazing-with-phoenix-project-structure-463l), with some personal modifications. Each feature is in a folder, inside its parent feature, and so on, following the schema relations.

```
encheres_immo/
    [...config files]
    
    - accounts/
        - accounts.ex (multi-schema context) 
        
        - organizations/
            - organizations.ex (context)
            - organization.ex (schema)
            - [...utils]
            - formulas/
                - formulas.ex (child context)
                - formula.ex (child schema)
            - [...other child folders]
    
        - users/
            - users.ex (context)
            - user.ex (schema)
            - [...utils]
            - [...child folders]
```

This solution has several advantages:  fewer files at the root, coherent structures throughout, and allowing multi-schema contexts (if necessary). Also, module names follow schema relations:

```
EncheresImmo.Accounts.Organizations.Formulas.Formula
Lib > Parent > Parent > Context > Schema
```

One of the downsides of this solution is that it may result in more and more folders nested inside folders, making it challenging to access deeply nested files. With time, module names will be longer and harder to guess, such as : `EncheresImmo.Accounts.Organizations.PaymentInfos.Cards.Card`.

Finally, complex relations like `Users`-`Orgs` or many-to-many tables can be tricky to represent as a nested hierarchy.

### Scrolling hell

<Asterism />

For thought, we can try the opposite approach:

```
encheres_immo/
    [...config files]
    
    - organizations/
        - users.ex (context)
        - user.ex (schema)
        - [...utils]

    - formulas/
        - formulas.ex (child context)
        - formula.ex (child schema)
    
    - users/
        - users.ex (context)
        - user.ex (schema)
        - [...utils]
```

Like the previous solution, we clean files at the root and get a coherent structure throughout. But this time, every schema has its folder with context/schema/utils, making module names easy to guess.

```
EncheresImmo.Users.User
Lib -> Context -> Schema
```

However, there are drawbacks to this solution, including a potentially large number of folders at the root level, with no clear distinction between the central feature and the small sub-feature. Also, folder structure and module names do not represent schema relations. 

### Messy hell

<Asterism />

Proposed by the other developer, not tested :

```
encheres_immo/
    - accounts/
        accounts.ex
        user.ex
        organization.ex
        utils/
            [...utils]

    - auctions/
        auctions.ex
        auction.ex
        currency.ex
        utils/
            [...utils]

    - contacts/
        contacts.ex
        contact.ex
        utils/
            [...utils]
```

Pros:
  -  Even simpler than previous solutions.
  -  Good for situations where the primary distinction is just between contexts and utility functions.
  
Cons:
  - The distinction between contexts and schemas isn't as explicit, which might be slightly less intuitive for new developers.
  - I don't think there is a good reason for a multi-schemas context like `Accounts`. Looking at our code, I think there would only be functions that should be in a specific context, or functions that are bad practices.
  - This solution do not distinguish schemas/contexts which belong to larger features. In the case of `organization`, with multiple sub schemas/contexts, that could lead either to a messy folder : 

  ```
  encheres_immo/
      - accounts/
          accounts.ex
          custom_themes.ex
          formulas.ex
          payment_infos.ex
          [...]
          schemas/
              organization.ex
              user.ex
              custom_theme.ex
              formula.ex
              payment_info.ex
              [...]
          utils/
              [...utils]
  ```


## Our final proposal


Not the miracle solution, but I think I found one halfway of all our solutions:

```
encheres_immo/
‚îú‚îÄ organizations/ <- a folder for each feature
‚îÇ    ‚îú‚îÄ organizations.ex <- context 
‚îÇ    ‚îú‚îÄ organization.ex <- schema & changesets
‚îÇ    ‚îú‚îÄ ? - utils/ <- utils folder
‚îÇ    ‚îÇ       ‚îî‚îÄ [... utils].ex <- utils files 
‚îÇ    ‚îî‚îÄ ? -  formula/ <- subfolder for each child feature
‚îÇ            ‚îú‚îÄ formula.ex <- child schema & changesets
‚îÇ            ‚îú‚îÄ ? - formulas.ex <- child context 
‚îÇ            ‚îî‚îÄ ? - [... utils] <- child utils 
[...]
‚îú‚îÄ application.ex <- app life cycle
‚îú‚îÄ release.ex <- utils for migrations and seeding
‚îî‚îÄ [... repo related files]
```

"Feature" is a data structure (example: `user`), with a schema (and changesets), a context (functions to create/ use/ modify/ delete it), utils (optional - additional functions, boilerplates, templates, or behaviours), and child features (optional - embed or small tables).

"Child feature" is a simple schema/ embed (example: `formula`) with few to none context functions, and few to none utils. A child feature can't have a child feature itself. If a child feature grows into a feature, we should transfer it to its own folder. 

**Pros:**

- Easy to document (1 schema & 2 paragraphs) and understand (I think)
- Can be applied to most of our existing code (I'm currently trying on a branch)
- Limit folder nesting

**Cons:**

- Will eventually lead to a lot of folders at the root (more than B & C & D), but slower than A.
- Imply folder structure modification every time a child feature becomes a feature, which should be rare.

### About test files

<Asterism />

To respect legacy code and documention, we will keep a `test` folder at the root of the project, with a `test_helper.exs`.

-> Not the solution I would have chosen, but I think it's the best compromise between respecting the existing code and making it evolve.
-> In my personal project, I will try to move a test file in the folder of each feature, and see if it's possible to make it work.

## About the decision process

As I said in the introduction, this is one of my first big decisions as a tech lead. I wanted to involve the team in the process, not only to make a better decision or for democratic management, but also to reassure myself.

### How did we discuss it?

It was also the first opportunity to formalize my decision process, and I knew that writing would play a central part. Of course, some discussions happened in meetings, but I tried to keep a written trace of it, so I created a Github Issue. 

There are multiple benefits in using GitHub Issues. Firstly, these issues are stored in the repository, making them easily accessible. Additionally, writing allows us to express our thoughts clearly, illustrate them with examples, and review proposals from others. By doing so, we can see the progression of the discussion and how we reached the final decision.

We took a few days to discuss the proposal and make the necessary changes, but the effort paid off. By involving everyone, we made a more informed decision that everyone knows about. More oral meetings or rushing the decision alone would not have saved time in the long run.

### How did we document it?

<Asterism />

At the end of the discussion, we have to write down the final decision, and to document it.
-> Added in the `README.md` with a schema, and a few paragraphs.

In retrospect, I think it whould have been better to :
-> Open a PR with the final decision, and to discuss it in the comments and code review.
-> Allow others devs to comment on the PR, and to propose their changes to the documentation.
-> Have a file in `docs/` with the final decision, with more details.

## What I learned

Blabla.
